---
layout:     post                    # 使用的布局（不需要改）
title:      温故知新               # 标题 
subtitle:   决定你的高度不在于搬砖，打好地基尤其重要 #副标题
date:       2017-07-12              # 时间
author:     BY  Seaside                    # 作者
#header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - CS
---



# 数据类型
## 1.1 整数
以下是基本整数关键词：
• char: 有符号 8 位整数。
• short: 有符号 16 位整数。
• int: 有符号 32 位整数。
• long: 在 32 位系统是 32 整数 (long int)，在 64 位系统则是 64 位整数。
• long long: 有符号 64 位整数 (long long int)。
• bool: _Bool 类型， 8 位整数，在 stdbool.h 中定义了 bool / true / false 宏便于使⽤。
由于在不同系统上 char 可能代表有符号或⽆符号 8 位整数，因此建议使⽤ unsigned char 
signed char 来表⽰具体的类型。
在` stdint.h` 中定义了⼀些看上去更明确的整数类型。

```c
typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
#if __WORDSIZE == 64
    typedef long int int64_t;
    typedef unsigned long int uint64_t;
#else
__extension__
    typedef long long int int64_t;
    typedef unsigned long long int uint64_t;
#endif
```

字符常量默认是⼀个 int 整数，但编译器可以⾃⾏决定将其解释为 char 或 int。

```c
char c = 'a';
printf("%c, size(char)=%d, size('a')=%d;\n", c, sizeof(c), sizeof('a'));
//a, size(char)=1, size('a')=4;
```

指针是个有特殊⽤途的整数，在 stdint.h 中同样给出了其类型定义。

```c
/* Types for `void *' pointers. */
#if __WORDSIZE == 64
	typedef unsigned long int uintptr_t;
#else
	typedef unsigned int uintptr_t;
#endif
```



不过在代码中我们通常⽤ sizeof(char*) 这样的⽤法，省得去处理 32 位和 64 位的区别。

## 1.2 浮点数
C 提供了不同精度的浮点。
• float: 32 位 4 字节浮点数，精确度 6。
• double: 64 位 8 字节浮点数，精确度 15。
• long double: 80 位 10 字节浮点数，精确度 19 位。

## 字⾯值
字⾯值 (literal) 是源代码中⽤来描述固定值的记号 (token)，可能是整数、浮点数、字符、字符串。



## 函数

6.2 类型
注意区分定义 "函数类型" 和 "函数指针 类型"的区别。函数名是⼀个指向当前函数的指针。

```c
typedef void(func_t)(); // 函数类型
typedef void(*func_ptr_t)(); // 函数指针类型

void test(){
	printf("%s\n", __func__);
}

int main(int argc, char* argv[]){
    func_t* func = test; // 声明⼀个指针
    func_ptr_t func2 = test; // 已经是指针类型
    void (*func3)(); // 声明⼀个包含函数原型的函数指针变量
    func3 = test;
    func();
    func2();
    func3();
    return EXIT_SUCCESS;
}
```



## 6.4 修饰符
C99 修饰符:
• extern: 默认修饰符，⽤于函数表⽰ "具有外部链接的标识符"，这类函数可⽤于任何程序⽂
件。⽤于变量声明表⽰该变量在其他单元中定义。
• static: 使⽤该修饰符的函数仅在其所在编译单元 (源码⽂件) 中可⽤。还可以表⽰函数类的静态
变量。
• inline: 修饰符 inline 建议编译器将函数代码内联到调⽤处，但编译器可⾃主决定是否完成。通
常包含循环或递归函数不能被定义为 inline 函数。
24
GNU inline 相关说明:
• static inline: 内链接函数，在当前编译单元内内联。不过 -O0 时依然是 call。
• inline: 外连接函数，当前单元内联，外部单元为普通外连接函数 (头⽂件中不能添加 inline 关
键字)。
附： inline 关键字只能⽤在函数定义处。



## 指针
###  void 指针
void* ⼜被称为万能指针，可以代表任何对象的地址，但没有该对象的类型。也就是说必须转型后才能进⾏对象操作。 void* 指针可以与其他任何类型指针进⾏隐式转换

### 初始化指针
可以⽤初始化器初始化指针。
• 空指针常量 NULL。
• 相同类型的指针，或者指向限定符较少的相同类型指针。
• void 指针。
⾮⾃动周期指针变量或静态⽣存期指针变量必须⽤编译期常量表达式初始化，⽐如函数名称等。





## 数组指针
注意下⾯代码中指针的区别。

```c
int x[] = {1,2,3,4,5,6};
int p1 = x; ! // 指向整数的指针
int (p2)[] = &x; ! // 指向数组的指针
```

p1 的类型是 `int *`，也就是说它指向⼀个整数类型。数组名默认指向数组中的第⼀个元素，因此 x 默认也是 `int*` 类型。
p2 的含义是指向⼀个 **数组类型**的指针，注意是 "数组类型" ⽽不是 "数组元素类型"，这有本质上的区别。数组指针把数组当做⼀个整体，因为从类型⾓度来说，数组类型和数组元素类型是两个概念。因此`p2 = &x` 当中 x 代表的是数组本⾝⽽不是数组的第⼀个元素地址， &x 取的是数组指针，⽽不是"第⼀个元素指针的指针"。

接下来，我们看看如何⽤数组指针操作⼀维数组。

```c
void array1(){
    int x[] = {1,2,3,4,5,6};
    int (p)[] = &x; // 指针 p 指向数组
    for(int i = 0; i < 6; i++){
   		printf("%d\n", (p)[i]); // p 返回该数组, (p)[i] 相当于 x[i]
    }
}
```

`p = &x` 使得指针 p 存储了该数组的指针， *p ⾃然就是获取该数组。那么 (*\*p)[i] 也就等于 x[i]。
注意: p 的目标类型是数组，因此 p++ 指向的不是数组下⼀个元素，⽽是 "整个数组之后” 位置 `(EA+sizeof(x))`，这已经超出数组范围了。

数组指针对⼆维数组的操作。

```c
void array2(){
    int x = {{1, 2, 3, 4}, {11, 22, 33, 44}};
    int (p)[4] = x; // 相当于 p = &x[0]
    for(int i = 0; i < 2; i++){
        for (int c = 0; c < 4; c++){
        	printf("[%d, %d] = %d\n", i, c, (p)[c]);
        }
        p++;
    }
} 
//printf("[1, 3] = %d\n", ((p + 1))[3]);
```

x是⼀个⼆维数组， x 默认指向该数组的第⼀个元素，也就是 {1,2,3,4}。不过要注意，这第⼀个元素不是 int，⽽是⼀个 int[]， x 实际上是` int(*)[] `指针。因此 "p = x" ⽽不是 "p = &x"，否则 p 就指向` int (*)[][] `了。
既然 p 指向第⼀个元素，那么 *p ⾃然也就是第⼀⾏数组了，也就是 {1,2,3,4}， (*p)[2] 的含义就是第⼀⾏的第三个元素。 p++ 的结果⾃然也就是指向下⼀⾏。我们还可以直接⽤ \***(p + 1)** 来访问x[1]。

```c
void array3()
{
    int x = {{1, 2, 3, 4}, {11, 22, 33, 44}};
    int (p) = &x;
    for(int i = 0; i < 2; i++){
        for (int c = 0; c < 4; c++){
        	printf("[%d, %d] = %d\n", i, c, (*p)i);
        }
    }
}
```


我们继续看看` int (*)[][]` 的例⼦。

这回 "p = &x"，也就是说把整个⼆维数组当成⼀个整体，因此 *p 返回的是整个⼆维数组，因此 p+也就⽤不得了。
附: 在附有初始化的数组声明语句中，只有第⼀维度可以省略。 将数组指针当做函数参数传递。*

```c
void test1(p,len)
	int(p)[];
	int len;
{
    for(int i = 0; i < len; i++){
    	printf("%d\n", (p)[i]);
    }
}
void test2(void* p, int len){
    int(pa)[] = p;
    for(int i = 0; i < len; i++){
    	printf("%d\n", (pa)[i]);
    }
}
int main (int args, char* argv[]){
    int x[] = {1,2,3};
    test1(&x, 3);
    test2(&x, 3);
    return 0;
}
```


由于数组指针类型中有括号，因此 test1 的参数定义看着有些古怪，不过习惯就好了。