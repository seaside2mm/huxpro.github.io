---
layout:     post                    # 使用的布局（不需要改）
title:     bolt源码梳理(中)--深入代码分析实现               # 标题 
subtitle:   走多了便成了路 #副标题
date:       2018-08-24              # 时间
author:     BY  Seaside                    # 作者
#header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - bolt， database

---



# Update的实现过程

刚才讲了Update的操作是会写入到文件中进行持久化的，结合上节中的内容，我们可以很容易的理解其中的流程。

```go
func (db *DB) Update(fn func(*Tx) error) error {
   //生成一个新的Tx对象
   t, err := db.Begin(true)  
   if err != nil {  
      return err  
   }
   //执行匿名函数，如果成功则Commit写入文件，如果不成功则回滚
   err = fn(t) 
   if err != nil {  
      _ = t.Rollback()  
      return err  
   }  
  
   return t.Commit()  
}
```

Begin生成了一个新的Tx对象，并赋予了它一个meta对象，从上文的图中我们知道meta对象中保存了一个默认的bucket（这个默认bucket的page id为3，也就是创建数据库文件时生成的page中的最后一个），所以Tx中的一切都要从这个bucket开始寻找。 假设我们传入的fn的内容为

```go
tx.CreateBucket([]byte("my_bucket"))
```

Tx找到自己的默认bucket，然后在默认bucket中创建新的bucket。

```go
func (b *Bucket) CreateBucket(key []byte) (*Bucket, error) {
   //在该bucket的inodes中寻找这个key
   //inodes中可能没有这个key，因为boltdb并不会把所有的数据读取到inodes中来
   //如果inodes中没有的话就只有去page里面将所有的数据读出来挨个找这个key
   c := b.Cursor()  
   k, _, flags := c.seek(key)  
   
   //如果找到了就说明存在这个key，然么创建失败
   if bytes.Equal(key, k) {  
      if (flags & bucketLeafFlag) != 0 {  
         return nil, ErrBucketExists  
      }  
      return nil, ErrIncompatibleValue  
   }  
  //新创建的bucket都是使用inline类型的page，如果这个bucket下有了子bucket才会为其分配独立的page  
  var bucket = Bucket{  
      bucket:      &bucket{},  
      rootNode:    &node{isLeaf: true},  
      FillPercent: DefaultFillPercent,  
  } 
  //将bucket的内容序列化为[]byte
  var value = bucket.write()  
  
   key = cloneBytes(key)
   //将bucket序列化后的value保存在默认bucket的inodes中
   //由于inodes是切片，所以会按照key来排序插入到对应的位置
   c.node().put(key, key, value, 0, bucketLeafFlag)  
   //将bucket对应的结构体存放在父bucket的buckets切片中
   return b.Bucket(key), nil  
}
```

假如我们在Update的匿名函数中存放了一对key-value：

```go
some_bucket.Put([]byte("mykey"), []byte("myvalue"))
```

Put方法的实现如下：

```go
func (b *Bucket) Put(key []byte, value []byte) error {  
   // 在inodes或者page中寻找这个key
   c := b.Cursor()  
   k, _, flags := c.seek(key)  
  
   //如果找到了就返回一个错误
   if bytes.Equal(key, k) && (flags&bucketLeafFlag) != 0 {  
      return ErrIncompatibleValue  
   }  
  
    
   key = cloneBytes(key)  
   //插入到inodes中
   c.node().put(key, key, value, 0, 0)  
   return nil  
}
```

从CreateBucket和Put两个方法中，读者可以看出两个方法的唯一区别在于CreateBucket会创建一个bucket并序列化为[]byte。所以本质上而言，对父bucket而言，子bucket跟普通数据一样都是[]byte。

从上面的分析可以知道，Update的匿名函数中新生成的数据会被挂在inodes上面，所以在Commit阶段，就会将这些信息写回到文件中存储起来。

```go
func (tx *Tx) Commit() error {  
   //……
   //将inodes中的数据写到page上面
   if err := tx.root.spill(); err != nil {  
      tx.rollback()  
      return err  
   }
   //将目前空闲的所有page的id写入到某个freelist page上面，而meta始终会记录这这个freelist page的id。
   //这样的话，每次读取数据库文件的时候，读取开头的meta信息，就可以知道freelist page的id是多少，然后找到这个page，读取即可知道文件中有哪些空闲的表
   //以后某个时候，如果需要新的page，那么就可以直接使用这些page即可，节省了文件空间。
   tx.db.freelist.free(tx.meta.txid, tx.db.page(tx.meta.freelist))  
   p, err := tx.allocate((tx.db.freelist.size() / tx.db.pageSize) + 1)  
   if err != nil {  
      tx.rollback()  
   return err  
}  
   if err := tx.db.freelist.write(p); err != nil {  
      tx.rollback()  
   return err  
   }  
   tx.meta.freelist = p.id
   //……
   //将所有涉及修改的page同步回文件中。（同步之前在Mmap中）
   if err := tx.write(); err != nil {  
      tx.rollback()  
      return err  
   }  
   //……
     
   tx.close()
  
   return nil  
}
```

至此就分析了一次事务中，数据是如何存储的：从page (mmap)中读取信息 -> 找到bucket -> 对bucket执行读写操作，保存的信息写入到inodes中 -> 事务结束时将inodes中的信息写回到page中(mmap) -> 将mmap中的数据同步回文件中持久化。

回想最开始创建数据库文件的时候，会想这个文件中默认的写入4个page：2个meta page，1个 freelist page， 1个数据page。 2个meta page永远在文件最开始的位置，记录着freelist所在的page，和默认bucket所在的page。通过寻找默认bucket，就可以找到旗下的用户创建的bucket，进而寻找到其他的page 上。 在上文中，我们讲了，如果要在一个bucket中寻找某个key，如果这个bucket的inodes中找不到，那么就会去它所属的page上面找，那么如何在page上找到这个key呢？ 要知道这个，我们应该看inodes上的数据是如何写到page上的，而从page上读数据就是这个操作的反操作。

## 数据page结构

从上文的spill方法开始，这个方法将bucket下所有的inodes信息写到page上。

```go
//spill是一个递归调用，会从下到上先写入子bucket，在写入父bucket
func (b *Bucket) spill() error {  
   // 遍历子bucket
   // 对整个bucket树来说，只有叶节点是inline类型的
   for name, child := range b.buckets {  
   //如果子bucket是inline类型的（参见上文），那么就直接将序列话后的[]byte作为value，key是bucket的名字
   if child.inlineable() {  
      //释放掉原来的inline page
      child.free()  
      //将bucket的数据写入到inline page中
      value = child.write()  
   } else {
	  //如果是普通类型的bucket，就递归先更新子bucket的子bucket
      if err := child.spill(); err != nil {  
         return err  
      }
      //仅将子bucket的头部来作为value
      value = make([]byte, unsafe.Sizeof(bucket{}))  
      var bucket = (*bucket)(unsafe.Pointer(&value[0]))  
      *bucket = *child.bucket  
   }
   var c = b.Cursor()  
   k, _, flags := c.seek([]byte(name))  
   c.node().put([]byte(name), []byte(name), value, 0, bucketLeafFlag)  
   }
```

上面那个递归实现可知，write才是真正写入page的函数

```go
func (b *Bucket) write() []byte {  
   // 分配一块空间 
   var n = b.rootNode  
   var value = make([]byte, bucketHeaderSize+n.size())  
  
   // 写入bucket头部
   var bucket = (*bucket)(unsafe.Pointer(&value[0]))  
   *bucket = *b.bucket  
   
   //通过强制转换，在value的后续空间中写入bucket内的inodes的信息
   var p = (*page)(unsafe.Pointer(&value[bucketHeaderSize]))  
   n.write(p)  
  
   return value  
}
func (n *node) write(p *page) {  
   // Initialize page.  
  if n.isLeaf {  
      p.flags |= leafPageFlag  
  } else {  
      p.flags |= branchPageFlag  
  }  
   //计算需要写入的数目
   p.count = uint16(len(n.inodes))  
  
   // Stop here if there are no items to write.  
   if p.count == 0 {  
      return  
   }  
  
   //b指向需要写入数据的位置
   b := (*[maxAllocSize]byte)(unsafe.Pointer(&p.ptr))[n.pageElementSize()*len(n.inodes):]  
   //遍历所有的inodes
   for i, item := range n.inodes {  
 
      if n.isLeaf {  
         //elem指向写入key-value元数据的位置
         elem := p.leafPageElement(uint16(i))
         //elem所代表的key-value的存储位置距这个elem的相对距离
         elem.pos = uint32(uintptr(unsafe.Pointer(&b[0])) - uintptr(unsafe.Pointer(elem)))  
         elem.flags = item.flags
         //key的字节长度
         elem.ksize = uint32(len(item.key))  
         //value的字节长度
         elem.vsize = uint32(len(item.value))  
      } else {  
         elem := p.branchPageElement(uint16(i))  
         elem.pos = uint32(uintptr(unsafe.Pointer(&b[0])) - uintptr(unsafe.Pointer(elem)))  
         elem.ksize = uint32(len(item.key))  
         elem.pgid = item.pgid
      }
  
      //写入对应的key， value
      copy(b[0:], item.key)  
      b = b[klen:]  
      copy(b[0:], item.value)  
      b = b[vlen:]  
   }  
  
   // DEBUG ONLY: n.dump()  
}
```

可能看了上面的代码，读者还是不太清楚一个数据 page的结构，可以参考下图来理解上文代码。![page 结构](https://ryanyux.github.io/post/go-blotdb-source/datapage.jpg)所以，对于每个page，都会有一个page header，保存了一些page的信息。page.ptr代表着数据的开始位置。如果一个node中有N个inode，那么就会有N个128bit大小的elem，然后再是紧密排列的N对key-value对。





# 